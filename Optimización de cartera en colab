# --- Librerías ---
import pandas as pd
import numpy as np
from scipy.optimize import minimize
from google.colab import files
import matplotlib.pyplot as plt

# --- 1. Subir archivo ---
uploaded = files.upload()
nombre_archivo = list(uploaded.keys())[0]

# --- 2. Cargar datos ---
# Detectar automáticamente columna de fecha
df = pd.read_csv(nombre_archivo)

# Buscar columna que contenga la palabra 'fecha' o 'date'
fecha_col = None
for col in df.columns:
    if "fecha" in col.lower() or "date" in col.lower():
        fecha_col = col
        break

if fecha_col:
    df[fecha_col] = pd.to_datetime(df[fecha_col], errors="coerce")
    df.set_index(fecha_col, inplace=True)
    print(f"✅ Columna de fecha detectada: {fecha_col}")
else:
    print("⚠ No se encontró una columna de fecha automáticamente, usando primera columna como índice.")
    df.iloc[:,0] = pd.to_datetime(df.iloc[:,0], errors="coerce")
    df.set_index(df.columns[0], inplace=True)

# Asegurar frecuencia mensual
df = df.resample("M").last()

print("Archivo cargado:", nombre_archivo)
print(df.head())

# --- 3. Limpiar datos y calcular rendimientos logarítmicos ---
df_cleaned = df.replace(0, np.nan).dropna()
returns = np.log(df_cleaned / df_cleaned.shift(1)).dropna()

# --- 4. Datos para Markowitz ---
mean_returns = returns.mean() * 12       # Rendimiento anualizado (mensual -> anual)
cov_matrix = returns.cov() * 12          # Covarianza anualizada
num_assets = len(mean_returns)

# --- 5. Funciones ---
def portfolio_performance(weights, mean_returns, cov_matrix, rf=0.0):
    ret = np.dot(weights, mean_returns)
    vol = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))
    sharpe = (ret - rf) / vol
    return ret, vol, sharpe

def neg_sharpe(weights, mean_returns, cov_matrix, rf=0.0):
    return -portfolio_performance(weights, mean_returns, cov_matrix, rf)[2]

def portfolio_variance(weights, mean_returns, cov_matrix):
    return portfolio_performance(weights, mean_returns, cov_matrix)[1]**2

# --- 6. Restricciones ---
constraints = ({'type':'eq', 'fun': lambda x: np.sum(x) - 1})
bounds = tuple((0, 1) for _ in range(num_assets))

# --- 7. Optimización ---
result_sharpe = minimize(neg_sharpe, num_assets*[1./num_assets],
                         args=(mean_returns, cov_matrix),
                         method='SLSQP', bounds=bounds, constraints=constraints)

result_minvar = minimize(portfolio_variance, num_assets*[1./num_assets],
                         args=(mean_returns, cov_matrix),
                         method='SLSQP', bounds=bounds, constraints=constraints)

weights_sharpe = result_sharpe.x
weights_minvar = result_minvar.x

# --- 8. Frontera eficiente ---
def efficient_frontier(mean_returns, cov_matrix, num_points=100):
    results = np.zeros((3, num_points))
    target_returns = np.linspace(mean_returns.min(), mean_returns.max(), num_points)

    for i, ret in enumerate(target_returns):
        constraints_ef = (
            {'type':'eq','fun': lambda x: np.sum(x)-1},
            {'type':'eq','fun': lambda x: np.dot(x, mean_returns)-ret}
        )
        result = minimize(lambda w: np.sqrt(np.dot(w.T, np.dot(cov_matrix, w))),
                          num_assets*[1./num_assets],
                          method='SLSQP', bounds=bounds,
                          constraints=constraints_ef)
        if result.success:
            vol = np.sqrt(np.dot(result.x.T, np.dot(cov_matrix, result.x)))
            results[0,i] = vol
            results[1,i] = ret
            results[2,i] = ret/vol
    return results

ef_results = efficient_frontier(mean_returns, cov_matrix)

# --- 9. Resultados ---
df_resultados = pd.DataFrame({
    'Activos': mean_returns.index,
    'Pesos Sharpe': np.round(weights_sharpe,4),
    'Pesos Min Var': np.round(weights_minvar,4)
})
print("\nPesos óptimos de cartera Markowitz:")
print(df_resultados)

df_resultados.to_excel("resultados_optimizacion_markowitz.xlsx", index=False)

# --- 10. Gráfico ---
plt.figure(figsize=(10,6))
valid_ef_results = ef_results[:, ~np.isnan(ef_results[0,:])]
plt.plot(valid_ef_results[0,:], valid_ef_results[1,:], 'r--', linewidth=2, label='Frontera eficiente')

ret_sh, vol_sh, _ = portfolio_performance(weights_sharpe, mean_returns, cov_matrix)
plt.scatter(vol_sh, ret_sh, marker='*', color='g', s=200, label='Máx Sharpe')

ret_mv, vol_mv, _ = portfolio_performance(weights_minvar, mean_returns, cov_matrix)
plt.scatter(vol_mv, ret_mv, marker='o', color='b', s=200, label='Min Var')

plt.title('Frontera Eficiente - Portafolios Óptimos (Datos Mensuales)')
plt.xlabel('Volatilidad (anual)')
plt.ylabel('Rendimiento Esperado (anual)')
plt.legend()
plt.grid(True)
plt.show()



